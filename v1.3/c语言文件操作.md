# 文件操作
操作文件的正确流程为：`打开文件` --> `读写文件` --> `关闭文件`。文件在进行**读写**操作**之前要先打开，使用完毕要关闭。** 
> 所谓打开文件，就是获取文件的有关信息，例如文件名、文件状态、当前读写位置等，这些信息会被保存到一个 FILE 类型的结构体变量中。  
> 所谓关闭文件，就是断开与文件之间的联系，释放结构体变量，同时禁止再对该文件进行操作。

**文件流与数据流**
- 文件流：数据在文件和内存之间传递的过程叫做`文件流`。数据从文件复制到内存的过程叫做`输入流`，从内存保存到文件的过程叫做`输出流`。  
- 数据流(Data Stream)：数据在数据源和程序（内存）之间传递的过程叫做`数据流`。数据从数据源到程序（内存）的过程叫做`输入流(Input Stream)`，从程序（内存）到数据源的过程叫做`输出流(Output Stream)`。  

## 文件的打开与关闭
所谓“打开文件”，就是让程序和文件建立连接的过程。使用`fopen()`函数即可打开文件，它的用法为：
```c
/*
* fopen - 使用给定的模式mode打开filename所指向的文件。
* 头文件：
*      #include<stdio.h>
* 参数：
*      @filename:要打开的文件名称
*      @mode    :文件的访问模式 
* 返回值：
*      成功返回该流的文件指针；失败返回NULL,并把错误代码存在error中
*/
FILE* fopen(char* filename,char*mode);
```
### 文件的打开方式(`mode`)
控制读写权限的字符串
| 打开方式 | 说明 |
| ------ | ------ |
| `r` | 以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。 |
| `w` | 以“写入”方式打开文件。若文件存在，则清空文件内容。反之则创建一个新文件。|
| `a` | 以“追加(append)”方式打开文件。与`w`的区别在于：如果文件存在，那么将写入的数据追加到文件的末尾（不覆盖）。|
| `r+`|以“读写”方式打开文件。若文件不存在，则打开失败。|
| `w+`|以“写入/更新”方式打开文件。若文件存在，则清空文件内容。反之则创建一个新文件。|
| `a+`|以“追加/更新”方式打开文件。与`w+`的区别在于：如果文件存在，那么将写入的数据追加到文件的末尾（不覆盖）。|

控制读写权限的字符串（可选）
| 打开方式 | 说明 |
| ------ | ------ |
| `t` |文本文件。|
| `b` |二进制文件。|  

文本文件与二进制文件在计算机上都是以二进制数字0和1存储数据，没有本质差异，都是由数字0和1构成的集合。两者的差异体现在编码逻辑“  ”
> 文本文件：本文件是基于字符编码的文件，一般采用定长编码方式，比如`ASCII`编码、`UNICODE`编码。其中`ASCII`编码采用8个特定的比特来表示每一个字符，而`UNICODE`编码采用16比特。  
> 二进制文件：二进制文件直接由二进制数字0和1组成，不存在统一的字符编码，也就是说由你来决定多少个比特表示一个什么值，你可以根据具体的应用来指定这些比特的含义，类似于自定义编码，而且是不定长度的编码。  

读写权限和读写方式可以组合使用，但是必须将读写方式放在读写权限的中间或者尾部（换句话说，不能将读写方式放在读写权限的开头）。实例如下

```
    rb:以 只读 的方式打开二进制文件；
    at:以 追加 的方式打开文本文件
    rb+:以 读写的方式打开二进制文件
    ...
```

### 文件的关闭
文件一旦使用完毕，应该用 `fclose()` 函数把文件关闭，以释放相关资源，避免数据丢失。`fclose()` 的用法为：
```c
/*
* fclose - 关闭一个流
* 头文件：
*        #include<stdio.h>
* 参数
*        @stream:   要关闭的流
*返回值：
*        如果流成功关闭，返回 0；否则返回EOF（-1）。
*/
int fclose(FILE* stream);
```

## 文件的读写
### 1.字符形式的读写
以字符形式读写文件时，每次可以从文件中读取一个字符，或者向文件中
写入一个字符。主要使用两个函数，分别是 `fgetc()` 和 `fputc()`。
```c
/*
*fgetc - 从文件指针stream指向的文件中读取一个字符，读取一个字节后，光标位置后移一个字节
* 头文件：
*     #include<stdio.h>
* 参数：
*     @stream: 输入流
* 返回值:
*     读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF。
*/
int fgetc(FILE* stream);

/*
* fputc - 将字符c写到文件指针fp所指向的文件的当前写指针的位置
* 头文件：
*     #include<stdio.h>
* 参数：
*     @stream: 输入流
*     @ch    : stream
* 返回值：
*   在正常调用情况下，函数返回写入文件的字符的ASCII码值，出错时，返回EOF（-1）。
*   当正确写入一个字符或一个字节的数据后，文件内部写指针会自动后移一个字节的位置。
*/
int fputc (int ch, FILE *stream );
```
***在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用 fgetc() 函数后，该指针会向后移动一个字节，所以可以连续多次使用 fgetc() 读取多个字符。***
```c
#include<stdio.h>

int main(){
    FILE *fp;
    //如果文件不存在，给出提示并退出
    if( (fp=fopen("D:\\demo.txt","rt+")) == NULL ){
        puts("Fail to open file!");
        exit(0);
    }
    //每次读取一个字节，直到读取完毕
    char ch;
    while( (ch=fgetc(fp)) != EOF )
        putchar(ch);
    putchar('\n');  //输出换行符
    //操作完毕，关闭文件
    fclose(fp); 
    return 0;
}
```
### 2.字符串形式的读写
实际开发中往往是每次读写一个字符串或者一个数据块，这样能明显提高效率。读字符串函数 `fgets()`、写字符串函数 `fputs()`:
```c
/*
*fgets - 从指定的流中读取数据，每次读取一行。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止
*头文件：
*       #include<stdio.h>
*参数：
*       @str-- 这是指向一个字符数组的指针，该数组存储了要读取的字符串。
*       @n-- 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。
*       @stream-- 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。
*返回值：读取成功时返回字符数组首地址，也即 str；读取失败时返回 NULL；
*       如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 NULL。
*/
char* fgets(char* str,int n,FILE *stream);

/*
*fputs() - 是向指定的文件写入一个字符串（不自动写入字符串结束标记符‘\0’）。
*          成功写入一个字符串后，文件的位置指针会自动后移，函数返回值为非负整数；否则返回EOF
* 头文件
*       #include<stdio.h>
* 参数：
*       @str    :需要写入文件的字符串
*       @stream ：需要写入的文件流
* 返回值：
*       写入成功返回非负数，失败返回 EOF。
*/
int fputs(const char *str, FILE *stream);
```
### 3.以数据块的形式读写
`fgets()` 每次最多只能从文件中读取一行内容。如果希望读取多行内容，需要使用`fread()`函数；相应地写入函数为 `fwrite()`。  
> 所谓块数据，也就是若干个字节的数据，可以是一个字符，可以是一个字符串，可以是多行数据，并没有什么限制。
```c
/*
* fread()- 从指定文件中读取块数据。fwrite() - 函数用来向文件中写入块数据
* 头文件
*       #include<stdio.h>
* 参数：
*       @ptr  :内存区块的指针。它可以是数组、变量、结构体等。
*              fread()  中的 ptr 用来存放读取到的数据；
*              fwrite() 中的 ptr 用来存放要写入的数据。
*       @size ：表示每个数据块的字节数。
*       @count：表示要读写的数据块的块数。
*       @fp   ：表示文件指针。
* 返回值：返回成功读写的块数，也即 count。若返回值小于count：
*         对于 fwrite() 来说，肯定发生了写入错误，可以用 ferror() 函数检测。
*         对于 fread() 来说，可能读到了文件末尾，可能发生了错误，可用 ferror() 或 feof() 检测。
*                                
*/
size_t fread (void *ptr, size_t size, size_t count, FILE *fp );
size_t fwrite(void *ptr, size_t size, size_t count, FILE *fp );
```

*从键盘输入两个学生数据，写入一个文件中，再读出这两个学生的数据显示在屏幕上*   
```c
#include<stdio.h>
#define N 2

struct stu{
    char name[10]; //姓名
    int num;  //学号
    int age;  //年龄
    float score;  //成绩
}boya[N], boyb[N], *pa, *pb;

int main(){
    FILE *fp;
    int i;
    pa = boya;
    pb = boyb;
    if( (fp=fopen("d:\\demo.txt", "wb+")) == NULL ){
        puts("Fail to open file!");
        exit(0);
    }

    //从键盘输入数据
    printf("Input data:\n");
    for(i=0; i<N; i++,pa++)
        scanf("%s %d %d %f",pa->name, &pa->num,&pa->age, &pa->score);

    //将数组 boya 的数据写入文件
    fwrite(boya, sizeof(struct stu), N, fp);
    //将文件指针重置到文件开头
    rewind(fp);
    //从文件读取数据并保存到数据 boyb
    fread(boyb, sizeof(struct stu), N, fp);

    //输出数组 boyb 中的数据
    for(i=0; i<N; i++,pb++)
        printf("%s  %d  %d  %f\n", pb->name, pb->num, pb->age, pb->score);

    fclose(fp);
    return 0;
}
```
### 随机读写
前面介绍的文件读写函数都是顺序读写，即读写文件只能从头开始，依次读写各个数据。
但在实际开发中经常需要读写文件的中间部分，要解决这个问题，就得先移动文件内部
的位置指针，再进行读写。这种读写方式称为随机读写，也就是说从文件的任意位置开始读写。
